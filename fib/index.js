// sixth
// --- Directions
// Print out the n-th entry in the fibonacci series.
// The fibonacci series is an ordering of numbers where
// each number is the sum of the preceeding two.
// For example, the sequence
//  [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
// forms the first ten entries of the fibonacci series.
// Example:
//   fib(4) === 3



// ITERATIVE SOlUTION using a for loop
// we're going to create an array, and then assemble all the numbers up to entry n
// we'll produce everything up to that element and then we'll return it
// The RUNTIME COMPLEXITY = for every increase in n we need to calculate 1 additional number. so as n increases by 1 we have to do one more calculation and thats never going to change.
// so this is LINEAR RUNTIME.
// shorter way to come to that conculsion is well we have a simple for loop and it looks like we are always starting out at some fixed number, always incrementing by 1, and always incrementing up to this fixed target.
// looks like we have a for loop that iterating through this close set, one for one. so chances are its linear run time
// function fib(n) {
//     // decalring an array that will hold our series of numbers
//     // the trick is to recognize with this iterative solution is that the first two entries cannot really be effectively generated by a for loop bc the algorithm that we r using here is saying look at the previous two numbers, add them together, and that gives us the element that we want to add to the series.
//     // so for [0, 1], theres no previous two entries that we can add together. However we always know that it will start with zero and one, so the best way of handling this is to just manually insert zero and one into the result set
//     const result = [0, 1]
//     // now to produce the third element, we can add together 0 and 1 to produce 1 and then continue throughout the rest of the series just like that
//     // so we're going to use a for loop and going to start at i = 2 bc we want to produce the 1 element first and then we're going to iterate up to n.
//     for(let i = 2; i <= n; i++){
//         // now in the for loop we need to pull out the previous two records and then we will add them together and push that into the result set array
//         // to get the previous two records we can either look at the variable i and subtract 1, and then subtract 2. Or we can take results.length - 1.
//         const a = result[i - 1] // this is first when the loop runs, i = 2 so a will be receiving the second element which is 1 
//         const b = result[i - 2] // and then b will be calculated by taking 2 - 2 = 0, and that is the first element in the result set
//         // then we'll add these two numbers together so a + b and push them in the result array
//         result.push(a + b) //this is going to generate our fibonacci series until the entry n

//     }
//     // last thing is return entry n from our result set
//     return result[n]
//     // or return result[result.length - 1] to get the last record
// }


// RECURSIVE SOLTUION
// the onlty time where a number is actually being returned is when n is less 2
// so when n is equal to zero or one thats the only time when we're going to return an actual discreet number 
// the way it works is we keep on calling fibonacci with smaller and smaller numbers until we eventually we meet the base case and return some actual value

// PERFORMANCE
// It would be exponential runtime. Because for each additional element that we add into our collection or for each increment of our value n to our function, we are experiencing a dramatic increase in the number of function calls that are required.
//  any exponential time algorithm u create is a big automatic no no. we never want to accept an exponential time algorithm as a solution to an interview question
// any time we start seeing a exponential runtime function, it usually means that theres a different solution we can put together that might be much more efficient in nature. 
// if an interviewer asks if you can improve the recursive solution, yes you can show them the iterative solution and maybe the'll let you get away with that but if they ask for improvement for the recursive solution, they want to hear something very particular
// well you know im looking through all these different function calls bc we know when we call fib 6, we're calling fibonacci all these different times and when you look through this chart right here, you start to realize that the function is being called many times with identical arguments. so if there is some way we can avoid all the extra function calls then if we call fib with 6 then all we have to worry about is doing the computation stuff for fib 5, 4, 3, 2, 1, 0 exactly one time
// They want to hear one word. MEMOIZATION
// when we memoize a function, we are going to record the arguments of each function call. so we're going to record the arguments, we're going to run the function and then we're going to store the result of that function call.
// memoization - is when you store the arguments of each function call along with the result. If the function is called again with the same arguments, return the precomputed result, rather than running the function again. 
// in practice when we calculate fib 6, we're going to immediately make a call to fib 5. and thats going to make a call to fib 4. 
// we're going to call fibonacci with 4 and we're going to write some code that is going to say oh it looks like our fibonacci function is being called with an argument that has never been called with before, which is 4. we will then run the function with 4, we will take the result from that and we'll store it in a special location. So if fib 4 ever gets called again, we already have ran tht scenario, we don't have to execute the function again. we're going to go to that special place in memory and retrieve that precomputed result. 
// By doing the memoization process or by caching all the results that come out of the function, e can dramatically improve the run speed of this function. This is exact answer ur interviewer is asking for. they're asking u for a memoized solution.
// function fib(n){
//     if (n < 2){
//         return n
//     }

//     return fib(n - 1) + fib(n - 2)
// }

// MEMOIZED SOLUTION
// this technique can work in any interview setting with any memoization problem
// we're gonna take the slow version of fib, then we're going to pass it into this memoize function and then the memoize function will return a fast memoized version of fib.
// in other words we're calling a function within a function that returns a function

// passing a function to it and going to return a new function that is dramatically speeded up
// so whenver we call it, we're going to pass a function into it, which will receive it as an argument called fn, short for function
// then we will return a new function, the dramatically faster one.
function memoize(fn){
    // now we have to add some implementation to memoize. we need to declare some storage area, someplace where we can record all the arguments that r used to call the function and the respective result from all those function calls
    // we'll declare an object to store all of our calls to the fast version of our function
    const cache = {}
    return function(...args){
        // now we will receive some arguments to the inner function here
        // when we call memoize it return this function. this annonymous function is fib on this bottom
        // so the annonymous function right here will receive the arguments that were actually intended to be sent to the slow fib function and therefor we dont know how many arguments will be passed to this function bc we're making a generic version of memoize.
        // so we need to code this thing out to assume that we might be receiving multiple arguments - ...args - tht means idk how many arguments this function will be called with, just take all the arguments and assign them as an array to this variable called args. this is called defensive coding because we're saying idk how many arguments this thing will receive
        // we're going check to see if the function has ever been called with this particular set of arguments, so we're gonna look at the cache object and key args, and if something exists there - we will immediately return it and dont do anyother work, if not then
        if(cache[args]){
            return cache[args]
        } 

        // if we get past our if statement then that means that we've never called our function with that set of arguments before
        // so we need to make sure we call that function, take the result and cache it inside of our cache object
        // this will be the result of calling our slow fib function 
        // whenever we call a function with an array of arguments, we have to use the apply helper. so we're gonna call apply and pass in this and args
        const result = fn.apply(this, args)
        // next we're going to take the result from calling our slow fib function and store it inside of our cache object
        // so at the cache object, at the key args, store the result that we just created
        cache[args] = result

        return result
    }   
}

function fib(n){
    if (n < 2){
        return n
    }

    return fib(n - 1) + fib(n - 2)
}

// an example of how we would use this thing in reality would be to do something like this
// we take our slow function, pass it to memoize and then thats going to return a new function, assign it to fib and then we will export the memoized version from this file
fib = memoize(fib)

module.exports = fib;
